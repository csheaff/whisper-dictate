#!/usr/bin/env bash
#
# talktype — push-to-talk speech-to-text for Linux
#
# Bind to a keyboard shortcut. Press once to start recording,
# press again to stop, transcribe, and type the text wherever
# your cursor is.
#
# Transcription is pluggable: set TALKTYPE_CMD to any command that
# takes a WAV file path as its last argument and prints text to stdout.
#
# Requires: ydotool, pw-record (PipeWire)
#
set -euo pipefail

# ── Load user config (works from GNOME shortcuts, cron, etc.) ──
TALKTYPE_CONFIG="${TALKTYPE_CONFIG:-${XDG_CONFIG_HOME:-$HOME/.config}/talktype/config}"
# shellcheck disable=SC1090
[ -f "$TALKTYPE_CONFIG" ] && source "$TALKTYPE_CONFIG"

TALKTYPE_DIR="${TALKTYPE_DIR:-${XDG_RUNTIME_DIR:-/tmp}/talktype}"
PIDFILE="$TALKTYPE_DIR/rec.pid"
AUDIOFILE="$TALKTYPE_DIR/rec.wav"
NOTIFYFILE="$TALKTYPE_DIR/notify.id"

mkdir -p "$TALKTYPE_DIR"

# ── Default transcription command (faster-whisper) ──
# Override with TALKTYPE_CMD to use any transcriber, e.g.:
#   TALKTYPE_CMD="whisper-cpp -m /path/to/model.bin -f" talktype
#   TALKTYPE_CMD="my-custom-script" talktype
# The audio file path is appended as the last argument.
if [ -z "${TALKTYPE_CMD:-}" ]; then
    SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
    VENV_DIR="${TALKTYPE_VENV:-$SCRIPT_DIR/.venv}"
    WHISPER_MODEL="${WHISPER_MODEL:-base}"
    WHISPER_LANG="${WHISPER_LANG:-en}"
    WHISPER_DEVICE="${WHISPER_DEVICE:-cuda}"
    WHISPER_COMPUTE="${WHISPER_COMPUTE:-float16}"

    TALKTYPE_CMD="$VENV_DIR/bin/python3 $SCRIPT_DIR/transcribe $WHISPER_MODEL $WHISPER_LANG $WHISPER_DEVICE $WHISPER_COMPUTE"
fi

# ── Notification helper ──
notify() {
    local icon="$1" msg="$2"
    local -a args=(-a TalkType -u critical -i "$icon" -p "TalkType" "$msg")
    if [ -f "$NOTIFYFILE" ]; then
        args+=(-r "$(cat "$NOTIFYFILE")")
    fi
    notify-send "${args[@]}" 2>/dev/null | head -1 > "$NOTIFYFILE" || true
}

notify_close() {
    if [ -f "$NOTIFYFILE" ]; then
        notify-send -a TalkType -r "$(cat "$NOTIFYFILE")" -e "TalkType" "" 2>/dev/null || true
        rm -f "$NOTIFYFILE"
    fi
}

# ── Check core dependencies ──
check_deps() {
    local missing=()
    command -v ydotool    &>/dev/null || missing+=(ydotool)
    command -v ffmpeg &>/dev/null || command -v pw-record &>/dev/null || missing+=("ffmpeg or pipewire")
    command -v notify-send &>/dev/null || missing+=(libnotify-bin)

    if [ ${#missing[@]} -gt 0 ]; then
        echo "Missing: ${missing[*]}" >&2
        notify-send -t 3000 -i dialog-error "TalkType" "Missing: ${missing[*]}" 2>/dev/null || true
        exit 1
    fi
}

check_deps

# ── If currently recording → stop, transcribe, type ──
if [ -f "$PIDFILE" ]; then
    PID=$(cat "$PIDFILE")
    kill "$PID" 2>/dev/null || true
    # Wait for recorder to finalize the file (not a child, so wait(1) won't work)
    while kill -0 "$PID" 2>/dev/null; do sleep 0.05; done
    rm -f "$PIDFILE"

    notify process-working "Transcribing..."

    # Run the transcription command with the audio file as last arg
    TEXT=$($TALKTYPE_CMD "$AUDIOFILE")

    rm -f "$AUDIOFILE"

    if [ -z "$TEXT" ]; then
        notify dialog-warning "No speech detected"
        exit 0
    fi

    notify_close

    # Type text at cursor via ydotool
    ydotool type --key-delay 50 -- "$TEXT"

# ── Otherwise → start recording ──
else
    # Use ffmpeg to record with a 1-second pre-roll buffer, so speech
    # that starts immediately on keypress is captured.
    if command -v ffmpeg &>/dev/null; then
        ffmpeg -loglevel quiet -f pulse -i default \
            -ac 1 -ar 16000 -f wav "$AUDIOFILE" &>/dev/null &
    else
        pw-record --format=s16 --rate=16000 --channels=1 "$AUDIOFILE" &>/dev/null &
    fi
    PID=$!
    disown "$PID"
    echo "$PID" > "$PIDFILE"
    notify audio-input-microphone "Listening..."
fi
